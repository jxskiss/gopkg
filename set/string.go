// Code generated by go generate at 2020-02-27T23:57:44+08:00; DO NOT EDIT.

package set

import "encoding/json"

// String is string set collection.
// The zero value of String is an empty instance ready to use. A zero String
// value shall not be copied, or it may result incorrect behavior.
type String struct {
	m map[string]struct{}
}

// NewString creates String instance.
func NewString(vals ...string) String {
	size := max(len(vals), minSize)
	set := String{
		m: make(map[string]struct{}, size),
	}
	set.Add(vals...)
	return set
}

// NewStringWithSize creates String instance with given initial size.
func NewStringWithSize(size int) String {
	set := String{
		m: make(map[string]struct{}, size),
	}
	return set
}

// Size returns the size of set.
func (s *String) Size() int { return len(s.m) }

// Add adds values into the set.
func (s *String) Add(vals ...string) {
	if s.m == nil {
		size := max(len(vals), minSize)
		s.m = make(map[string]struct{}, size)
	}
	for idx := range vals {
		s.m[vals[idx]] = struct{}{}
	}
}

// Del deletes values from the set.
func (s *String) Del(vals ...string) {
	for idx := range vals {
		delete(s.m, vals[idx])
	}
}

// Pop pops an element from the set, in no particular order.
func (s *String) Pop() string {
	for val := range s.m {
		delete(s.m, val)
		return val
	}
	return ""
}

// Iterate iterates the set in no particular order and call the given function
// for each set element.
func (s *String) Iterate(fn func(string)) {
	for val := range s.m {
		fn(val)
	}
}

// Contains returns true if the set contains all the values.
func (s *String) Contains(vals ...string) bool {
	if len(vals) == 0 {
		return false
	}
	for _, v := range vals {
		if _, ok := s.m[v]; !ok {
			return false
		}
	}
	return true
}

// ContainsAny returns true if the set contains any of the values.
func (s *String) ContainsAny(vals ...string) bool {
	for _, v := range vals {
		if _, ok := s.m[v]; ok {
			return true
		}
	}
	return false
}

// Diff returns new String about the values which other set doesn't contain.
func (s String) Diff(other String) String {
	res := NewStringWithSize(s.Size())

	for val := range s.m {
		if _, ok := other.m[val]; !ok {
			res.m[val] = struct{}{}
		}
	}
	return res
}

// DiffSlice is similar to Diff, but takes a slice as parameter.
func (s String) DiffSlice(other []string) String {
	if len(s.m) > len(other) {
		tmp := NewStringWithSize(len(other))
		dup := 0
		for _, val := range other {
			if _, ok := s.m[val]; ok {
				dup++
			}
			tmp.m[val] = struct{}{}
		}
		res := NewStringWithSize(max(s.Size()-dup, 0))
		for val := range s.m {
			if _, ok := tmp.m[val]; !ok {
				res.m[val] = struct{}{}
			}
		}
		return res
	} else {
		res := NewStringWithSize(s.Size())
		for val := range s.m {
			res.m[val] = struct{}{}
		}
		for _, val := range other {
			if _, ok := res.m[val]; ok {
				delete(res.m, val)
			}
		}
		return res
	}
}

// FilterInclude returns a new slice which contains values that present in
// the provided slice and also present in the String set.
func (s String) FilterInclude(slice []string) []string {
	res := make([]string, 0, min(s.Size(), len(slice)))
	for _, val := range slice {
		if _, ok := s.m[val]; ok {
			res = append(res, val)
		}
	}
	return res
}

// FilterExclude returns a new slice which contains values that present in
// the provided slice but don't present in the String set.
func (s String) FilterExclude(slice []string) []string {
	res := make([]string, 0, len(slice))
	for _, val := range slice {
		if _, ok := s.m[val]; !ok {
			res = append(res, val)
		}
	}
	return res
}

// Intersect returns new String about values which other set also contains.
func (s String) Intersect(other String) String {
	res := NewStringWithSize(min(s.Size(), other.Size()))

	// loop over the smaller set
	if len(s.m) <= len(other.m) {
		for val := range s.m {
			if _, ok := other.m[val]; ok {
				res.m[val] = struct{}{}
			}
		}
	} else {
		for val := range other.m {
			if _, ok := s.m[val]; ok {
				res.m[val] = struct{}{}
			}
		}
	}
	return res
}

// IntersectSlice is similar to Intersect, but takes a slice as parameter.
func (s String) IntersectSlice(other []string) String {
	res := NewStringWithSize(min(s.Size(), len(other)))

	for _, val := range other {
		if _, ok := s.m[val]; ok {
			res.m[val] = struct{}{}
		}
	}
	return res
}

// Union returns new String about values either in the set or the other set.
func (s String) Union(other String) String {
	res := NewStringWithSize(s.Size() + other.Size())

	for val := range s.m {
		res.m[val] = struct{}{}
	}
	for val := range other.m {
		res.m[val] = struct{}{}
	}
	return res
}

// UnionSlice is similar to Union, but takes a slice as parameter.
func (s String) UnionSlice(other []string) String {
	res := NewStringWithSize(s.Size() + len(other))

	for val := range s.m {
		res.m[val] = struct{}{}
	}
	for _, val := range other {
		res.m[val] = struct{}{}
	}
	return res
}

// Slice converts set into string slice.
func (s String) Slice() []string {
	res := make([]string, 0, len(s.m))

	for val := range s.m {
		res = append(res, val)
	}
	return res
}

// Map converts set into map[string]bool.
func (s String) Map() map[string]bool {
	res := make(map[string]bool, len(s.m))

	for val := range s.m {
		res[val] = true
	}
	return res
}

// MarshalJSON implements json.Marshaler interface, the set will be
// marshaled as an string array.
func (s String) MarshalJSON() ([]byte, error) {
	res := s.Slice()
	return json.Marshal(res)
}

// UnmarshalJSON implements json.Unmarshaler interface, it will unmarshal
// an string array to the set.
func (s *String) UnmarshalJSON(b []byte) error {
	vals := make([]string, 0)
	err := json.Unmarshal(b, &vals)
	if err == nil {
		s.Add(vals...)
	}
	return err
}
