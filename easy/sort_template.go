// +build ignore

// This program generates sorting utilities for concrete types.
// It can be invoked by running `go generate`.
package main

import (
	"bytes"
	"go/format"
	"io/ioutil"
	"log"
	"text/template"
	"time"
)

type Type struct {
	Type      string
	SliceType string
}

func main() {
	var targetTypes = []Type{
		{"int8", "Int8s"},
		{"uint8", "Uint8s"},
		{"int16", "Int16s"},
		{"uint16", "Uint16s"},
		{"int32", "Int32s"},
		{"uint32", "Uint32s"},
		{"int", "Ints"},
		{"uint", "Uints"},
		{"uintptr", "Uintptrs"},
		{"int64", "Int64s"},
		{"uint64", "Uint64s"},
		{"float32", "Float32s"},
		{"float64", "Float64s"},
		{"string", "Strings"},
	}

	tmpl := template.New("")
	tmpl = template.Must(tmpl.New("header").Parse(headertmpl))
	tmpl = template.Must(tmpl.New("code").Parse(codetmpl))

	var buf bytes.Buffer
	if err := tmpl.ExecuteTemplate(&buf, "header", map[string]interface{}{
		"Now": time.Now().Format(time.RFC3339),
	}); err != nil {
		log.Fatal(err)
	}
	for _, t := range targetTypes {
		if err := tmpl.ExecuteTemplate(&buf, "code", t); err != nil {
			log.Fatal(err)
		}
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	if err = ioutil.WriteFile("sort_gen.go", out, 0644); err != nil {
		log.Fatal(err)
	}
}

var headertmpl = `// Code generated by go generate at {{ .Now }}; DO NOT EDIT.

package easy

//go:generate go run sort_template.go

import "sort"

`

var codetmpl = `

// {{ .SliceType }}Asc attaches the methods of sort.Interface to []{{ .Type }}, sorting in ascending order.
type {{ .SliceType }}Asc []{{ .Type }}

func (x {{ .SliceType }}Asc) Len() int           { return len(x) }
func (x {{ .SliceType }}Asc) Less(i, j int) bool { return x[i] < x[j] }
func (x {{ .SliceType }}Asc) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }

// Sort is a convenience method which calls sort.Sort(x).
func (x {{ .SliceType }}Asc) Sort() { sort.Sort(x) }

// {{ .SliceType }}Desc attaches the methods of sort.Interface to []{{ .Type }}, sorting in descending order.
type {{ .SliceType }}Desc []{{ .Type }}

func (x {{ .SliceType }}Desc) Len() int           { return len(x) }
func (x {{ .SliceType }}Desc) Less(i, j int) bool { return x[i] > x[j] }
func (x {{ .SliceType }}Desc) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }

// Sort is a convenience method which calls sort.Sort(x).
func (x {{ .SliceType }}Desc) Sort() { sort.Sort(x) }

// Sort{{ .SliceType }}Asc is a convenience method which calls sort.Sort({{ .SliceType }}Asc(x)).
func Sort{{ .SliceType }}Asc(x []{{ .Type }}) { sort.Sort({{ .SliceType }}Asc(x)) }

// Sort{{ .SliceType }}Desc is a convenience method which calls sort.Sort({{ .SliceType }}Desc(x)).
func Sort{{ .SliceType }}Desc(x []{{ .Type }}) { sort.Sort({{ .SliceType }}Desc(x)) }

// {{ .SliceType }}AreSortedAsc is a convenience method which calls sort.IsSorted({{ .SliceType }}Asc(x)).
func {{ .SliceType }}AreSortedAsc(x []{{ .Type }}) bool { return sort.IsSorted({{ .SliceType }}Asc(x)) }

// {{ .SliceType }}AreSortedDesc is a convenience method which calls sort.IsSorted({{ .SliceType }}Desc(x)).
func {{ .SliceType }}AreSortedDesc(x []{{ .Type }}) bool { return sort.IsSorted({{ .SliceType }}Desc(x)) }

// InSorted{{ .SliceType }} tells whether elem is in a sorted {{ .Type }} slice.
// The given slice must be sorted in either ascending order or
// descending, else it may give incorrect result.
func InSorted{{ .SliceType }}(slice []{{ .Type }}, elem {{ .Type }}) bool {
	length := len(slice)
	if length == 0 {
		return false
	}
	if length == 1 || slice[0] == slice[length-1] {
		return slice[0] == elem
	}

	var less func(i int) bool
	if slice[0] <= slice[length-1] {
		// ascending order
		less = func(i int) bool { return slice[i] >= elem }
	} else {
		// descending order
		less = func(i int) bool { return slice[i] <= elem }
	}
	i := sort.Search(length, less)
	return i < len(slice) && slice[i] == elem
}
`
