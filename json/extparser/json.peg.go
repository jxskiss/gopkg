package extparser

// Code generated by peg json.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleDocument
	ruleJSON
	ruleObject
	ruleObjectKey
	ruleArray
	ruleImport
	ruleSimpleIdentifier
	ruleString
	ruleSingleQuoteLiteral
	ruleDoubleQuoteLiteral
	ruleSingleQuoteEscape
	ruleDoubleQuoteEscape
	ruleUnicodeEscape
	ruleHexDigit
	ruleTrue
	ruleFalse
	ruleNull
	ruleNumber
	ruleMinus
	ruleIntegralPart
	ruleFractionalPart
	ruleExponentPart
	ruleSpacing
	ruleWhitespace
	ruleLongComment
	ruleLineComment
	rulePragma
	ruleLWING
	ruleRWING
	ruleLBRK
	ruleRBRK
	ruleCOMMA
	ruleCOLON
	ruleEOT
)

var rul3s = [...]string{
	"Unknown",
	"Document",
	"JSON",
	"Object",
	"ObjectKey",
	"Array",
	"Import",
	"SimpleIdentifier",
	"String",
	"SingleQuoteLiteral",
	"DoubleQuoteLiteral",
	"SingleQuoteEscape",
	"DoubleQuoteEscape",
	"UnicodeEscape",
	"HexDigit",
	"True",
	"False",
	"Null",
	"Number",
	"Minus",
	"IntegralPart",
	"FractionalPart",
	"ExponentPart",
	"Spacing",
	"Whitespace",
	"LongComment",
	"LineComment",
	"Pragma",
	"LWING",
	"RWING",
	"LBRK",
	"RBRK",
	"COMMA",
	"COLON",
	"EOT",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type JSON struct {
	Buffer string
	buffer []rune
	rules  [35]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *JSON) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *JSON) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *JSON
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *JSON) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *JSON) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *JSON) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*JSON) error {
	return func(p *JSON) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*JSON) error {
	return func(p *JSON) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *JSON) Init(options ...func(*JSON) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Document <- <(Spacing JSON EOT)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleSpacing]() {
					goto l0
				}
				if !_rules[ruleJSON]() {
					goto l0
				}
				if !_rules[ruleEOT]() {
					goto l0
				}
				add(ruleDocument, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 JSON <- <((Object / Array / String / True / False / Null / Number / Import) Spacing)> */
		func() bool {
			position2, tokenIndex2 := position, tokenIndex
			{
				position3 := position
				{
					position4, tokenIndex4 := position, tokenIndex
					if !_rules[ruleObject]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleArray]() {
						goto l6
					}
					goto l4
				l6:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleString]() {
						goto l7
					}
					goto l4
				l7:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleTrue]() {
						goto l8
					}
					goto l4
				l8:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleFalse]() {
						goto l9
					}
					goto l4
				l9:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleNull]() {
						goto l10
					}
					goto l4
				l10:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleNumber]() {
						goto l11
					}
					goto l4
				l11:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleImport]() {
						goto l2
					}
				}
			l4:
				if !_rules[ruleSpacing]() {
					goto l2
				}
				add(ruleJSON, position3)
			}
			return true
		l2:
			position, tokenIndex = position2, tokenIndex2
			return false
		},
		/* 2 Object <- <(LWING (ObjectKey COLON JSON COMMA)* (ObjectKey COLON JSON)? RWING)> */
		func() bool {
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if !_rules[ruleLWING]() {
					goto l12
				}
			l14:
				{
					position15, tokenIndex15 := position, tokenIndex
					if !_rules[ruleObjectKey]() {
						goto l15
					}
					if !_rules[ruleCOLON]() {
						goto l15
					}
					if !_rules[ruleJSON]() {
						goto l15
					}
					if !_rules[ruleCOMMA]() {
						goto l15
					}
					goto l14
				l15:
					position, tokenIndex = position15, tokenIndex15
				}
				{
					position16, tokenIndex16 := position, tokenIndex
					if !_rules[ruleObjectKey]() {
						goto l16
					}
					if !_rules[ruleCOLON]() {
						goto l16
					}
					if !_rules[ruleJSON]() {
						goto l16
					}
					goto l17
				l16:
					position, tokenIndex = position16, tokenIndex16
				}
			l17:
				if !_rules[ruleRWING]() {
					goto l12
				}
				add(ruleObject, position13)
			}
			return true
		l12:
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 3 ObjectKey <- <(String / SimpleIdentifier)> */
		func() bool {
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				{
					position20, tokenIndex20 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l21
					}
					goto l20
				l21:
					position, tokenIndex = position20, tokenIndex20
					if !_rules[ruleSimpleIdentifier]() {
						goto l18
					}
				}
			l20:
				add(ruleObjectKey, position19)
			}
			return true
		l18:
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 4 Array <- <(LBRK (JSON COMMA)* JSON? RBRK)> */
		func() bool {
			position22, tokenIndex22 := position, tokenIndex
			{
				position23 := position
				if !_rules[ruleLBRK]() {
					goto l22
				}
			l24:
				{
					position25, tokenIndex25 := position, tokenIndex
					if !_rules[ruleJSON]() {
						goto l25
					}
					if !_rules[ruleCOMMA]() {
						goto l25
					}
					goto l24
				l25:
					position, tokenIndex = position25, tokenIndex25
				}
				{
					position26, tokenIndex26 := position, tokenIndex
					if !_rules[ruleJSON]() {
						goto l26
					}
					goto l27
				l26:
					position, tokenIndex = position26, tokenIndex26
				}
			l27:
				if !_rules[ruleRBRK]() {
					goto l22
				}
				add(ruleArray, position23)
			}
			return true
		l22:
			position, tokenIndex = position22, tokenIndex22
			return false
		},
		/* 5 Import <- <('@' 'i' 'm' 'p' 'o' 'r' 't' '(' String ')')> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				if buffer[position] != rune('@') {
					goto l28
				}
				position++
				if buffer[position] != rune('i') {
					goto l28
				}
				position++
				if buffer[position] != rune('m') {
					goto l28
				}
				position++
				if buffer[position] != rune('p') {
					goto l28
				}
				position++
				if buffer[position] != rune('o') {
					goto l28
				}
				position++
				if buffer[position] != rune('r') {
					goto l28
				}
				position++
				if buffer[position] != rune('t') {
					goto l28
				}
				position++
				if buffer[position] != rune('(') {
					goto l28
				}
				position++
				if !_rules[ruleString]() {
					goto l28
				}
				if buffer[position] != rune(')') {
					goto l28
				}
				position++
				add(ruleImport, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 6 SimpleIdentifier <- <([0-9] / [A-Z] / [a-z] / '_' / '$')+> */
		func() bool {
			position30, tokenIndex30 := position, tokenIndex
			{
				position31 := position
				{
					position34, tokenIndex34 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l35
					}
					position++
					goto l34
				l35:
					position, tokenIndex = position34, tokenIndex34
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l36
					}
					position++
					goto l34
				l36:
					position, tokenIndex = position34, tokenIndex34
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l37
					}
					position++
					goto l34
				l37:
					position, tokenIndex = position34, tokenIndex34
					if buffer[position] != rune('_') {
						goto l38
					}
					position++
					goto l34
				l38:
					position, tokenIndex = position34, tokenIndex34
					if buffer[position] != rune('$') {
						goto l30
					}
					position++
				}
			l34:
			l32:
				{
					position33, tokenIndex33 := position, tokenIndex
					{
						position39, tokenIndex39 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l40
						}
						position++
						goto l39
					l40:
						position, tokenIndex = position39, tokenIndex39
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l41
						}
						position++
						goto l39
					l41:
						position, tokenIndex = position39, tokenIndex39
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l42
						}
						position++
						goto l39
					l42:
						position, tokenIndex = position39, tokenIndex39
						if buffer[position] != rune('_') {
							goto l43
						}
						position++
						goto l39
					l43:
						position, tokenIndex = position39, tokenIndex39
						if buffer[position] != rune('$') {
							goto l33
						}
						position++
					}
				l39:
					goto l32
				l33:
					position, tokenIndex = position33, tokenIndex33
				}
				add(ruleSimpleIdentifier, position31)
			}
			return true
		l30:
			position, tokenIndex = position30, tokenIndex30
			return false
		},
		/* 7 String <- <(SingleQuoteLiteral / DoubleQuoteLiteral)> */
		func() bool {
			position44, tokenIndex44 := position, tokenIndex
			{
				position45 := position
				{
					position46, tokenIndex46 := position, tokenIndex
					if !_rules[ruleSingleQuoteLiteral]() {
						goto l47
					}
					goto l46
				l47:
					position, tokenIndex = position46, tokenIndex46
					if !_rules[ruleDoubleQuoteLiteral]() {
						goto l44
					}
				}
			l46:
				add(ruleString, position45)
			}
			return true
		l44:
			position, tokenIndex = position44, tokenIndex44
			return false
		},
		/* 8 SingleQuoteLiteral <- <('\'' (SingleQuoteEscape / (!('\'' / '\\' / '\n' / '\r') .))* '\'')> */
		func() bool {
			position48, tokenIndex48 := position, tokenIndex
			{
				position49 := position
				if buffer[position] != rune('\'') {
					goto l48
				}
				position++
			l50:
				{
					position51, tokenIndex51 := position, tokenIndex
					{
						position52, tokenIndex52 := position, tokenIndex
						if !_rules[ruleSingleQuoteEscape]() {
							goto l53
						}
						goto l52
					l53:
						position, tokenIndex = position52, tokenIndex52
						{
							position54, tokenIndex54 := position, tokenIndex
							{
								position55, tokenIndex55 := position, tokenIndex
								if buffer[position] != rune('\'') {
									goto l56
								}
								position++
								goto l55
							l56:
								position, tokenIndex = position55, tokenIndex55
								if buffer[position] != rune('\\') {
									goto l57
								}
								position++
								goto l55
							l57:
								position, tokenIndex = position55, tokenIndex55
								if buffer[position] != rune('\n') {
									goto l58
								}
								position++
								goto l55
							l58:
								position, tokenIndex = position55, tokenIndex55
								if buffer[position] != rune('\r') {
									goto l54
								}
								position++
							}
						l55:
							goto l51
						l54:
							position, tokenIndex = position54, tokenIndex54
						}
						if !matchDot() {
							goto l51
						}
					}
				l52:
					goto l50
				l51:
					position, tokenIndex = position51, tokenIndex51
				}
				if buffer[position] != rune('\'') {
					goto l48
				}
				position++
				add(ruleSingleQuoteLiteral, position49)
			}
			return true
		l48:
			position, tokenIndex = position48, tokenIndex48
			return false
		},
		/* 9 DoubleQuoteLiteral <- <('"' (DoubleQuoteEscape / (!('"' / '\\' / '\n' / '\r') .))* '"')> */
		func() bool {
			position59, tokenIndex59 := position, tokenIndex
			{
				position60 := position
				if buffer[position] != rune('"') {
					goto l59
				}
				position++
			l61:
				{
					position62, tokenIndex62 := position, tokenIndex
					{
						position63, tokenIndex63 := position, tokenIndex
						if !_rules[ruleDoubleQuoteEscape]() {
							goto l64
						}
						goto l63
					l64:
						position, tokenIndex = position63, tokenIndex63
						{
							position65, tokenIndex65 := position, tokenIndex
							{
								position66, tokenIndex66 := position, tokenIndex
								if buffer[position] != rune('"') {
									goto l67
								}
								position++
								goto l66
							l67:
								position, tokenIndex = position66, tokenIndex66
								if buffer[position] != rune('\\') {
									goto l68
								}
								position++
								goto l66
							l68:
								position, tokenIndex = position66, tokenIndex66
								if buffer[position] != rune('\n') {
									goto l69
								}
								position++
								goto l66
							l69:
								position, tokenIndex = position66, tokenIndex66
								if buffer[position] != rune('\r') {
									goto l65
								}
								position++
							}
						l66:
							goto l62
						l65:
							position, tokenIndex = position65, tokenIndex65
						}
						if !matchDot() {
							goto l62
						}
					}
				l63:
					goto l61
				l62:
					position, tokenIndex = position62, tokenIndex62
				}
				if buffer[position] != rune('"') {
					goto l59
				}
				position++
				add(ruleDoubleQuoteLiteral, position60)
			}
			return true
		l59:
			position, tokenIndex = position59, tokenIndex59
			return false
		},
		/* 10 SingleQuoteEscape <- <('\\' ('b' / 't' / 'n' / 'f' / 'r' / '\'' / '\\' / '/' / UnicodeEscape))> */
		func() bool {
			position70, tokenIndex70 := position, tokenIndex
			{
				position71 := position
				if buffer[position] != rune('\\') {
					goto l70
				}
				position++
				{
					position72, tokenIndex72 := position, tokenIndex
					if buffer[position] != rune('b') {
						goto l73
					}
					position++
					goto l72
				l73:
					position, tokenIndex = position72, tokenIndex72
					if buffer[position] != rune('t') {
						goto l74
					}
					position++
					goto l72
				l74:
					position, tokenIndex = position72, tokenIndex72
					if buffer[position] != rune('n') {
						goto l75
					}
					position++
					goto l72
				l75:
					position, tokenIndex = position72, tokenIndex72
					if buffer[position] != rune('f') {
						goto l76
					}
					position++
					goto l72
				l76:
					position, tokenIndex = position72, tokenIndex72
					if buffer[position] != rune('r') {
						goto l77
					}
					position++
					goto l72
				l77:
					position, tokenIndex = position72, tokenIndex72
					if buffer[position] != rune('\'') {
						goto l78
					}
					position++
					goto l72
				l78:
					position, tokenIndex = position72, tokenIndex72
					if buffer[position] != rune('\\') {
						goto l79
					}
					position++
					goto l72
				l79:
					position, tokenIndex = position72, tokenIndex72
					if buffer[position] != rune('/') {
						goto l80
					}
					position++
					goto l72
				l80:
					position, tokenIndex = position72, tokenIndex72
					if !_rules[ruleUnicodeEscape]() {
						goto l70
					}
				}
			l72:
				add(ruleSingleQuoteEscape, position71)
			}
			return true
		l70:
			position, tokenIndex = position70, tokenIndex70
			return false
		},
		/* 11 DoubleQuoteEscape <- <('\\' ('b' / 't' / 'n' / 'f' / 'r' / '"' / '\\' / '/' / UnicodeEscape))> */
		func() bool {
			position81, tokenIndex81 := position, tokenIndex
			{
				position82 := position
				if buffer[position] != rune('\\') {
					goto l81
				}
				position++
				{
					position83, tokenIndex83 := position, tokenIndex
					if buffer[position] != rune('b') {
						goto l84
					}
					position++
					goto l83
				l84:
					position, tokenIndex = position83, tokenIndex83
					if buffer[position] != rune('t') {
						goto l85
					}
					position++
					goto l83
				l85:
					position, tokenIndex = position83, tokenIndex83
					if buffer[position] != rune('n') {
						goto l86
					}
					position++
					goto l83
				l86:
					position, tokenIndex = position83, tokenIndex83
					if buffer[position] != rune('f') {
						goto l87
					}
					position++
					goto l83
				l87:
					position, tokenIndex = position83, tokenIndex83
					if buffer[position] != rune('r') {
						goto l88
					}
					position++
					goto l83
				l88:
					position, tokenIndex = position83, tokenIndex83
					if buffer[position] != rune('"') {
						goto l89
					}
					position++
					goto l83
				l89:
					position, tokenIndex = position83, tokenIndex83
					if buffer[position] != rune('\\') {
						goto l90
					}
					position++
					goto l83
				l90:
					position, tokenIndex = position83, tokenIndex83
					if buffer[position] != rune('/') {
						goto l91
					}
					position++
					goto l83
				l91:
					position, tokenIndex = position83, tokenIndex83
					if !_rules[ruleUnicodeEscape]() {
						goto l81
					}
				}
			l83:
				add(ruleDoubleQuoteEscape, position82)
			}
			return true
		l81:
			position, tokenIndex = position81, tokenIndex81
			return false
		},
		/* 12 UnicodeEscape <- <('u' HexDigit HexDigit HexDigit HexDigit)> */
		func() bool {
			position92, tokenIndex92 := position, tokenIndex
			{
				position93 := position
				if buffer[position] != rune('u') {
					goto l92
				}
				position++
				if !_rules[ruleHexDigit]() {
					goto l92
				}
				if !_rules[ruleHexDigit]() {
					goto l92
				}
				if !_rules[ruleHexDigit]() {
					goto l92
				}
				if !_rules[ruleHexDigit]() {
					goto l92
				}
				add(ruleUnicodeEscape, position93)
			}
			return true
		l92:
			position, tokenIndex = position92, tokenIndex92
			return false
		},
		/* 13 HexDigit <- <([a-f] / [A-F] / [0-9])> */
		func() bool {
			position94, tokenIndex94 := position, tokenIndex
			{
				position95 := position
				{
					position96, tokenIndex96 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('f') {
						goto l97
					}
					position++
					goto l96
				l97:
					position, tokenIndex = position96, tokenIndex96
					if c := buffer[position]; c < rune('A') || c > rune('F') {
						goto l98
					}
					position++
					goto l96
				l98:
					position, tokenIndex = position96, tokenIndex96
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l94
					}
					position++
				}
			l96:
				add(ruleHexDigit, position95)
			}
			return true
		l94:
			position, tokenIndex = position94, tokenIndex94
			return false
		},
		/* 14 True <- <(('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e'))> */
		func() bool {
			position99, tokenIndex99 := position, tokenIndex
			{
				position100 := position
				{
					position101, tokenIndex101 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l102
					}
					position++
					if buffer[position] != rune('r') {
						goto l102
					}
					position++
					if buffer[position] != rune('u') {
						goto l102
					}
					position++
					if buffer[position] != rune('e') {
						goto l102
					}
					position++
					goto l101
				l102:
					position, tokenIndex = position101, tokenIndex101
					if buffer[position] != rune('T') {
						goto l99
					}
					position++
					if buffer[position] != rune('r') {
						goto l99
					}
					position++
					if buffer[position] != rune('u') {
						goto l99
					}
					position++
					if buffer[position] != rune('e') {
						goto l99
					}
					position++
				}
			l101:
				add(ruleTrue, position100)
			}
			return true
		l99:
			position, tokenIndex = position99, tokenIndex99
			return false
		},
		/* 15 False <- <(('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e'))> */
		func() bool {
			position103, tokenIndex103 := position, tokenIndex
			{
				position104 := position
				{
					position105, tokenIndex105 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l106
					}
					position++
					if buffer[position] != rune('a') {
						goto l106
					}
					position++
					if buffer[position] != rune('l') {
						goto l106
					}
					position++
					if buffer[position] != rune('s') {
						goto l106
					}
					position++
					if buffer[position] != rune('e') {
						goto l106
					}
					position++
					goto l105
				l106:
					position, tokenIndex = position105, tokenIndex105
					if buffer[position] != rune('F') {
						goto l103
					}
					position++
					if buffer[position] != rune('a') {
						goto l103
					}
					position++
					if buffer[position] != rune('l') {
						goto l103
					}
					position++
					if buffer[position] != rune('s') {
						goto l103
					}
					position++
					if buffer[position] != rune('e') {
						goto l103
					}
					position++
				}
			l105:
				add(ruleFalse, position104)
			}
			return true
		l103:
			position, tokenIndex = position103, tokenIndex103
			return false
		},
		/* 16 Null <- <(('n' 'u' 'l' 'l') / ('N' 'o' 'n' 'e'))> */
		func() bool {
			position107, tokenIndex107 := position, tokenIndex
			{
				position108 := position
				{
					position109, tokenIndex109 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l110
					}
					position++
					if buffer[position] != rune('u') {
						goto l110
					}
					position++
					if buffer[position] != rune('l') {
						goto l110
					}
					position++
					if buffer[position] != rune('l') {
						goto l110
					}
					position++
					goto l109
				l110:
					position, tokenIndex = position109, tokenIndex109
					if buffer[position] != rune('N') {
						goto l107
					}
					position++
					if buffer[position] != rune('o') {
						goto l107
					}
					position++
					if buffer[position] != rune('n') {
						goto l107
					}
					position++
					if buffer[position] != rune('e') {
						goto l107
					}
					position++
				}
			l109:
				add(ruleNull, position108)
			}
			return true
		l107:
			position, tokenIndex = position107, tokenIndex107
			return false
		},
		/* 17 Number <- <(Minus? IntegralPart FractionalPart? ExponentPart?)> */
		func() bool {
			position111, tokenIndex111 := position, tokenIndex
			{
				position112 := position
				{
					position113, tokenIndex113 := position, tokenIndex
					if !_rules[ruleMinus]() {
						goto l113
					}
					goto l114
				l113:
					position, tokenIndex = position113, tokenIndex113
				}
			l114:
				if !_rules[ruleIntegralPart]() {
					goto l111
				}
				{
					position115, tokenIndex115 := position, tokenIndex
					if !_rules[ruleFractionalPart]() {
						goto l115
					}
					goto l116
				l115:
					position, tokenIndex = position115, tokenIndex115
				}
			l116:
				{
					position117, tokenIndex117 := position, tokenIndex
					if !_rules[ruleExponentPart]() {
						goto l117
					}
					goto l118
				l117:
					position, tokenIndex = position117, tokenIndex117
				}
			l118:
				add(ruleNumber, position112)
			}
			return true
		l111:
			position, tokenIndex = position111, tokenIndex111
			return false
		},
		/* 18 Minus <- <'-'> */
		func() bool {
			position119, tokenIndex119 := position, tokenIndex
			{
				position120 := position
				if buffer[position] != rune('-') {
					goto l119
				}
				position++
				add(ruleMinus, position120)
			}
			return true
		l119:
			position, tokenIndex = position119, tokenIndex119
			return false
		},
		/* 19 IntegralPart <- <('0' / ([1-9] [0-9]*))> */
		func() bool {
			position121, tokenIndex121 := position, tokenIndex
			{
				position122 := position
				{
					position123, tokenIndex123 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l124
					}
					position++
					goto l123
				l124:
					position, tokenIndex = position123, tokenIndex123
					if c := buffer[position]; c < rune('1') || c > rune('9') {
						goto l121
					}
					position++
				l125:
					{
						position126, tokenIndex126 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l126
						}
						position++
						goto l125
					l126:
						position, tokenIndex = position126, tokenIndex126
					}
				}
			l123:
				add(ruleIntegralPart, position122)
			}
			return true
		l121:
			position, tokenIndex = position121, tokenIndex121
			return false
		},
		/* 20 FractionalPart <- <('.' [0-9]+)> */
		func() bool {
			position127, tokenIndex127 := position, tokenIndex
			{
				position128 := position
				if buffer[position] != rune('.') {
					goto l127
				}
				position++
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l127
				}
				position++
			l129:
				{
					position130, tokenIndex130 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l130
					}
					position++
					goto l129
				l130:
					position, tokenIndex = position130, tokenIndex130
				}
				add(ruleFractionalPart, position128)
			}
			return true
		l127:
			position, tokenIndex = position127, tokenIndex127
			return false
		},
		/* 21 ExponentPart <- <(('e' / 'E') ('+' / '-')? [0-9]+)> */
		func() bool {
			position131, tokenIndex131 := position, tokenIndex
			{
				position132 := position
				{
					position133, tokenIndex133 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l134
					}
					position++
					goto l133
				l134:
					position, tokenIndex = position133, tokenIndex133
					if buffer[position] != rune('E') {
						goto l131
					}
					position++
				}
			l133:
				{
					position135, tokenIndex135 := position, tokenIndex
					{
						position137, tokenIndex137 := position, tokenIndex
						if buffer[position] != rune('+') {
							goto l138
						}
						position++
						goto l137
					l138:
						position, tokenIndex = position137, tokenIndex137
						if buffer[position] != rune('-') {
							goto l135
						}
						position++
					}
				l137:
					goto l136
				l135:
					position, tokenIndex = position135, tokenIndex135
				}
			l136:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l131
				}
				position++
			l139:
				{
					position140, tokenIndex140 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l140
					}
					position++
					goto l139
				l140:
					position, tokenIndex = position140, tokenIndex140
				}
				add(ruleExponentPart, position132)
			}
			return true
		l131:
			position, tokenIndex = position131, tokenIndex131
			return false
		},
		/* 22 Spacing <- <(Whitespace / LongComment / LineComment / Pragma)*> */
		func() bool {
			{
				position142 := position
			l143:
				{
					position144, tokenIndex144 := position, tokenIndex
					{
						position145, tokenIndex145 := position, tokenIndex
						if !_rules[ruleWhitespace]() {
							goto l146
						}
						goto l145
					l146:
						position, tokenIndex = position145, tokenIndex145
						if !_rules[ruleLongComment]() {
							goto l147
						}
						goto l145
					l147:
						position, tokenIndex = position145, tokenIndex145
						if !_rules[ruleLineComment]() {
							goto l148
						}
						goto l145
					l148:
						position, tokenIndex = position145, tokenIndex145
						if !_rules[rulePragma]() {
							goto l144
						}
					}
				l145:
					goto l143
				l144:
					position, tokenIndex = position144, tokenIndex144
				}
				add(ruleSpacing, position142)
			}
			return true
		},
		/* 23 Whitespace <- <(' ' / '\t' / '\r' / '\n')+> */
		func() bool {
			position149, tokenIndex149 := position, tokenIndex
			{
				position150 := position
				{
					position153, tokenIndex153 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l154
					}
					position++
					goto l153
				l154:
					position, tokenIndex = position153, tokenIndex153
					if buffer[position] != rune('\t') {
						goto l155
					}
					position++
					goto l153
				l155:
					position, tokenIndex = position153, tokenIndex153
					if buffer[position] != rune('\r') {
						goto l156
					}
					position++
					goto l153
				l156:
					position, tokenIndex = position153, tokenIndex153
					if buffer[position] != rune('\n') {
						goto l149
					}
					position++
				}
			l153:
			l151:
				{
					position152, tokenIndex152 := position, tokenIndex
					{
						position157, tokenIndex157 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l158
						}
						position++
						goto l157
					l158:
						position, tokenIndex = position157, tokenIndex157
						if buffer[position] != rune('\t') {
							goto l159
						}
						position++
						goto l157
					l159:
						position, tokenIndex = position157, tokenIndex157
						if buffer[position] != rune('\r') {
							goto l160
						}
						position++
						goto l157
					l160:
						position, tokenIndex = position157, tokenIndex157
						if buffer[position] != rune('\n') {
							goto l152
						}
						position++
					}
				l157:
					goto l151
				l152:
					position, tokenIndex = position152, tokenIndex152
				}
				add(ruleWhitespace, position150)
			}
			return true
		l149:
			position, tokenIndex = position149, tokenIndex149
			return false
		},
		/* 24 LongComment <- <('/' '*' (!('*' '/') .)* ('*' '/'))> */
		func() bool {
			position161, tokenIndex161 := position, tokenIndex
			{
				position162 := position
				if buffer[position] != rune('/') {
					goto l161
				}
				position++
				if buffer[position] != rune('*') {
					goto l161
				}
				position++
			l163:
				{
					position164, tokenIndex164 := position, tokenIndex
					{
						position165, tokenIndex165 := position, tokenIndex
						if buffer[position] != rune('*') {
							goto l165
						}
						position++
						if buffer[position] != rune('/') {
							goto l165
						}
						position++
						goto l164
					l165:
						position, tokenIndex = position165, tokenIndex165
					}
					if !matchDot() {
						goto l164
					}
					goto l163
				l164:
					position, tokenIndex = position164, tokenIndex164
				}
				if buffer[position] != rune('*') {
					goto l161
				}
				position++
				if buffer[position] != rune('/') {
					goto l161
				}
				position++
				add(ruleLongComment, position162)
			}
			return true
		l161:
			position, tokenIndex = position161, tokenIndex161
			return false
		},
		/* 25 LineComment <- <('/' '/' (!('\r' / '\n') .)* ('\r' / '\n'))> */
		func() bool {
			position166, tokenIndex166 := position, tokenIndex
			{
				position167 := position
				if buffer[position] != rune('/') {
					goto l166
				}
				position++
				if buffer[position] != rune('/') {
					goto l166
				}
				position++
			l168:
				{
					position169, tokenIndex169 := position, tokenIndex
					{
						position170, tokenIndex170 := position, tokenIndex
						{
							position171, tokenIndex171 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l172
							}
							position++
							goto l171
						l172:
							position, tokenIndex = position171, tokenIndex171
							if buffer[position] != rune('\n') {
								goto l170
							}
							position++
						}
					l171:
						goto l169
					l170:
						position, tokenIndex = position170, tokenIndex170
					}
					if !matchDot() {
						goto l169
					}
					goto l168
				l169:
					position, tokenIndex = position169, tokenIndex169
				}
				{
					position173, tokenIndex173 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l174
					}
					position++
					goto l173
				l174:
					position, tokenIndex = position173, tokenIndex173
					if buffer[position] != rune('\n') {
						goto l166
					}
					position++
				}
			l173:
				add(ruleLineComment, position167)
			}
			return true
		l166:
			position, tokenIndex = position166, tokenIndex166
			return false
		},
		/* 26 Pragma <- <('#' (!('\r' / '\n') .)* ('\r' / '\n'))> */
		func() bool {
			position175, tokenIndex175 := position, tokenIndex
			{
				position176 := position
				if buffer[position] != rune('#') {
					goto l175
				}
				position++
			l177:
				{
					position178, tokenIndex178 := position, tokenIndex
					{
						position179, tokenIndex179 := position, tokenIndex
						{
							position180, tokenIndex180 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l181
							}
							position++
							goto l180
						l181:
							position, tokenIndex = position180, tokenIndex180
							if buffer[position] != rune('\n') {
								goto l179
							}
							position++
						}
					l180:
						goto l178
					l179:
						position, tokenIndex = position179, tokenIndex179
					}
					if !matchDot() {
						goto l178
					}
					goto l177
				l178:
					position, tokenIndex = position178, tokenIndex178
				}
				{
					position182, tokenIndex182 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l183
					}
					position++
					goto l182
				l183:
					position, tokenIndex = position182, tokenIndex182
					if buffer[position] != rune('\n') {
						goto l175
					}
					position++
				}
			l182:
				add(rulePragma, position176)
			}
			return true
		l175:
			position, tokenIndex = position175, tokenIndex175
			return false
		},
		/* 27 LWING <- <('{' Spacing)> */
		func() bool {
			position184, tokenIndex184 := position, tokenIndex
			{
				position185 := position
				if buffer[position] != rune('{') {
					goto l184
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l184
				}
				add(ruleLWING, position185)
			}
			return true
		l184:
			position, tokenIndex = position184, tokenIndex184
			return false
		},
		/* 28 RWING <- <('}' Spacing)> */
		func() bool {
			position186, tokenIndex186 := position, tokenIndex
			{
				position187 := position
				if buffer[position] != rune('}') {
					goto l186
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l186
				}
				add(ruleRWING, position187)
			}
			return true
		l186:
			position, tokenIndex = position186, tokenIndex186
			return false
		},
		/* 29 LBRK <- <('[' Spacing)> */
		func() bool {
			position188, tokenIndex188 := position, tokenIndex
			{
				position189 := position
				if buffer[position] != rune('[') {
					goto l188
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l188
				}
				add(ruleLBRK, position189)
			}
			return true
		l188:
			position, tokenIndex = position188, tokenIndex188
			return false
		},
		/* 30 RBRK <- <(']' Spacing)> */
		func() bool {
			position190, tokenIndex190 := position, tokenIndex
			{
				position191 := position
				if buffer[position] != rune(']') {
					goto l190
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l190
				}
				add(ruleRBRK, position191)
			}
			return true
		l190:
			position, tokenIndex = position190, tokenIndex190
			return false
		},
		/* 31 COMMA <- <(',' Spacing)> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				if buffer[position] != rune(',') {
					goto l192
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l192
				}
				add(ruleCOMMA, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 32 COLON <- <(':' Spacing)> */
		func() bool {
			position194, tokenIndex194 := position, tokenIndex
			{
				position195 := position
				if buffer[position] != rune(':') {
					goto l194
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l194
				}
				add(ruleCOLON, position195)
			}
			return true
		l194:
			position, tokenIndex = position194, tokenIndex194
			return false
		},
		/* 33 EOT <- <!.> */
		func() bool {
			position196, tokenIndex196 := position, tokenIndex
			{
				position197 := position
				{
					position198, tokenIndex198 := position, tokenIndex
					if !matchDot() {
						goto l198
					}
					goto l196
				l198:
					position, tokenIndex = position198, tokenIndex198
				}
				add(ruleEOT, position197)
			}
			return true
		l196:
			position, tokenIndex = position196, tokenIndex196
			return false
		},
	}
	p.rules = _rules
	return nil
}
